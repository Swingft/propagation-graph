import os
import json
import subprocess
from pathlib import Path
from concurrent.futures import ThreadPoolExecutor
from functools import partial
from typing import List, Dict
from tqdm import tqdm

SCRIPT_DIR = Path(__file__).resolve().parent
PROJECT_ROOT = SCRIPT_DIR.parent

ANALYZER_DIR = PROJECT_ROOT / "SwiftASTAnalyzer"
TARGET_DATA_ROOT = PROJECT_ROOT / "data"
OUTPUT_ROOT = PROJECT_ROOT / "input_label"


NEW_PROMPT_CONTEXT = """Your Role: You are an expert static analysis assistant with a deep understanding of Swift's semantic structure. Your mission is to meticulously analyze the provided symbol information to identify which symbols must have their names preserved during code obfuscation and to clearly justify your reasoning.

Input Data:
The input is a JSON object containing symbol information generated by analyzing Swift source code. Each symbol includes a `symbol_id`, a `symbol_name`, and an `input` field containing the data for analysis.

Procedure:
1.  **Symbol-by-Symbol Analysis**: For every symbol provided, thoroughly examine the data within its `input` field.
2.  **Identify Exclusions**: Identify symbols that must be excluded from obfuscation based on clear evidence matching one or more of the **'Core Analysis Patterns'** below.
3.  **Generate Output**: For the identified exclusion candidates only, generate a result conforming to the **'Output Format'** rules. Symbols that can be safely obfuscated should not be included in the final output.

Core Analysis Patterns (Decision Criteria):
-   **Runtime String References** (`objc_selector`, `stringly_typed_api`): When a symbol's name is referenced as a string at runtime, such as with `#selector` or `Notification.Name`.
-   **KVC/KVO and Data Binding** (`kvc_kvo`, `coredata_nsmanaged`): When a name is depended upon by mechanisms like `@NSManaged`, Key-Value Coding/Observing, or `KeyPath`.
-   **C Function Interface (FFI) Exposure** (`ffi_entry`): When a symbol is exposed to external C code via attributes like `@_cdecl`.
-   **Reflection** (`runtime_reflection`): When property names are used dynamically at runtime through APIs like `Mirror`.
-   **Codable Synthesis** (`codable_synthesis`): When the compiler automatically uses property names as keys, for instance, in JSON encoding/decoding.
-   **Resource Binding** (`resource_binding`): When a name is linked to external resources like Storyboard IDs, XIBs, or Asset names.
-   **External Contracts and Extensions** (`external_contract`): When a symbol is part of a framework's Public API.
-   **Dynamic Dispatch & ObjC Exposure** (`dynamic_dispatch`, `objc_exposed`): When a symbol is a target for ObjC runtime features via `dynamic` or `@objc` attributes.
-   **Protocol Requirement Implementation** (`protocol_requirement`): When a symbol is an implementation of a protocol's required method, property, etc.

Output Format:
The result is a JSON object containing **only the symbols that must be excluded from obfuscation**. Each symbol must consist of the following fields:

-   `symbol_name`: The pure name **excluding function arguments**.
    -   (e.g., `performRequest((endpoint: String))` -> `performRequest`)
-   `tags`: An array of standard tags corresponding to the reason for exclusion.
-   `rationale`: A clear, 1-2 sentence explanation for the exclusion, based on the `input` data.

Example Final Output:
{
  "methods": [
    {
      "symbol_name": "updateConfiguration",
      "tags": [
        "kvo"
      ],
      "rationale": "This method is declared '@objc dynamic' and can be a target for KVO (Key-Value Observing), requiring its name to be preserved."
    }
  ],
  "properties": [
    {
      "symbol_name": "baseURL",
      "tags": [
        "kvo"
      ],
      "rationale": "This property is declared '@objc dynamic' and can be a target for KVO (Key-Value Observing), requiring its name to be preserved."
    }
  ],
  "structs": [],
  "enums": []
}
"""

KEY_MAPPING = {
    "is_protocol_requirement_impl": "p1",
    "codable_synthesized": "p2",
    "access_level": "p3",
    "is_ffi_entry": "p4",
    "override_depth": "p5",
    "modifiers": "p6",
    "is_coredata_nsmanaged": "p7",
    "ast_path": "p8",
    "cross_module_refs": "p9",
    "is_objc_exposed": "p10",
    "type_signature": "p11",
    "extension_file_count_same_name": "p12",
    "is_swiftdata_model": "p13",
    "symbol_kind": "p14",
    "references": "p15",
    "calls_out": "p16",
    "selector_refs": "p17",
    "attributes": "p18",
    "extension_of": "p19",
    "inherits": "p20",
    "conforms": "p21"
}

def build_analyzer(analyzer_dir: Path) -> Path:
    """SwiftASTAnalyzer를 릴리즈 모드로 빌드하고 실행 파일 경로를 반환합니다."""
    print("🚀 SwiftASTAnalyzer 빌드를 시작합니다...")
    analyzer_bin_name = "swift-ast-analyzer"
    subprocess.run(
        ["swift", "build", "-c", "release"],
        cwd=analyzer_dir,
        check=True,
        capture_output=True,
        text=True,
    )
    print("✅ 빌드 완료!")
    analyzer_bin = analyzer_dir / ".build" / "release" / analyzer_bin_name
    if not analyzer_bin.exists():
        raise FileNotFoundError(f"빌드 후에도 실행 파일을 찾을 수 없습니다: {analyzer_bin}")
    return analyzer_bin


def find_swift_files(root: Path, target_dirs: List[str]) -> List[Path]:
    """지정된 디렉토리 내 모든 .swift 파일을 검색합니다."""
    print("🔎 Swift 파일을 검색합니다...")
    swift_files = []
    for dir_name in target_dirs:
        search_path = root / dir_name
        if search_path.is_dir():
            files_found = list(search_path.rglob("*.swift"))
            swift_files.extend(files_found)
            print(f"   - '{search_path}'에서 {len(files_found)}개의 파일을 찾았습니다.")
    print(f"✨ 총 {len(swift_files)}개의 Swift 파일을 찾았습니다.")
    return swift_files


def update_prompt_context(data: dict, new_context: str) -> dict:
    """JSON 데이터의 meta.prompt_context 값을 새로운 내용으로 교체합니다."""
    if 'meta' in data and isinstance(data['meta'], dict):
        data['meta']['prompt_context'] = new_context
    return data


def compact_input_keys(decisions_data: Dict, mapping: Dict) -> Dict:
    """'input' 객체 내부의 키를 매핑에 따라 간결한 코드로 변환합니다."""
    if not isinstance(decisions_data, dict):
        return decisions_data

    for category_list in decisions_data.values():
        if isinstance(category_list, list):
            for symbol_obj in category_list:
                if 'input' in symbol_obj and isinstance(symbol_obj['input'], dict):
                    original_input = symbol_obj['input']
                    compacted_input = {
                        mapping.get(key, key): value for key, value in original_input.items()
                    }
                    symbol_obj['input'] = compacted_input
    return decisions_data


def analyze_single_file(
        swift_file: Path, analyzer_bin: Path, data_root: Path, output_root: Path
):
    """단일 Swift 파일을 분석하고, 키 간결화 및 정리를 수행한 후 JSON으로 저장합니다."""
    try:
        relative_path = swift_file.relative_to(data_root)
        output_dir = output_root / relative_path.parent
        output_dir.mkdir(parents=True, exist_ok=True)
        output_file = output_dir / f"input_{swift_file.stem}.json"

        result = subprocess.run(
            [str(analyzer_bin), str(swift_file)],
            capture_output=True, text=True, check=True, encoding="utf-8",
        )

        original_data = json.loads(result.stdout)

        # 1. 'decisions' 데이터 추출 및 키 간결화
        decisions_data = original_data.get('decisions', {})
        decisions_data = compact_input_keys(decisions_data, KEY_MAPPING)

        # 2. 'decisions' 딕셔너리 내부 정리 (빈 배열 속성 및 카테고리 제거)
        if isinstance(decisions_data, dict):
            for category_list in decisions_data.values():
                if isinstance(category_list, list):
                    for symbol_obj in category_list:
                        if 'input' in symbol_obj and isinstance(symbol_obj['input'], dict):
                            keys_to_remove = [
                                key for key, value in symbol_obj['input'].items()
                                if isinstance(value, list) and not value
                            ]
                            for key in keys_to_remove:
                                del symbol_obj['input'][key]

            keys_to_remove = [
                key for key, value in decisions_data.items()
                if isinstance(value, list) and not value
            ]
            for key in keys_to_remove:
                del decisions_data[key]

        # 3. 최종 출력 구조 생성
        final_output = {
            "mapping": KEY_MAPPING,
            "data": {
                "meta": original_data.get('meta', {}),
                "decisions": decisions_data
            }
        }

        # 4. prompt_context 업데이트
        final_output['data'] = update_prompt_context(final_output['data'], NEW_PROMPT_CONTEXT)

        # 5. 최종 결과를 파일에 저장
        cleaned_json_string = json.dumps(final_output, indent=2, ensure_ascii=False)
        output_file.write_text(cleaned_json_string, encoding="utf-8")

        return None

    except json.JSONDecodeError:
        return f"❌ {swift_file} 분석 실패: Swift 분석기가 유효한 JSON을 생성하지 않았습니다."
    except subprocess.CalledProcessError as e:
        return f"❌ {swift_file} 분석 실패:\n{e.stderr}"
    except Exception as e:
        return f"❌ {swift_file} 처리 중 예외 발생:\n{e}"


def main():
    try:
        analyzer_bin = build_analyzer(ANALYZER_DIR)
    except (subprocess.CalledProcessError, FileNotFoundError) as e:
        print(f"🔥 빌드 실패: {e}")
        return

    target_dirs_to_scan = ["claude_generated", "gemini_generated"]
    swift_files = find_swift_files(TARGET_DATA_ROOT, target_dirs_to_scan)
    if not swift_files:
        print("⚠️ 분석할 Swift 파일이 없습니다. 스크립트를 종료합니다.")
        return

    OUTPUT_ROOT.mkdir(parents=True, exist_ok=True)
    print(f"\n⚙️ 총 {len(swift_files)}개 파일에 대한 병렬 분석을 시작합니다...")

    worker_func = partial(
        analyze_single_file,
        analyzer_bin=analyzer_bin,
        data_root=TARGET_DATA_ROOT,
        output_root=OUTPUT_ROOT,
    )

    errors = []
    with ThreadPoolExecutor(max_workers=os.cpu_count()) as executor:
        results = list(tqdm(
            executor.map(worker_func, swift_files),
            total=len(swift_files),
            desc="파일 분석 중"
        ))

    for res in results:
        if res is not None:
            errors.append(res)

    print("\n--- 분석 완료 ---")
    if not errors:
        print(f"🎉 모든 파일({len(swift_files)}개)이 성공적으로 처리되었습니다!")
    else:
        print(f"🔥 {len(errors)}개의 파일에서 오류가 발생했습니다:")
        for error_log in errors:
            print(error_log)


if __name__ == "__main__":
    main()
