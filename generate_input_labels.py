import os
import json
import subprocess
from pathlib import Path
from concurrent.futures import ThreadPoolExecutor
from functools import partial
from typing import List
from tqdm import tqdm


ANALYZER_DIR = Path("SwiftASTAnalyzer")
ANALYZER_BIN_NAME = "swift-ast-analyzer"
TARGET_DATA_ROOT = Path("data")
TARGET_DIRS_NAMES = ["gpt_generated", "claude_generated", "gemini_generated"]
OUTPUT_ROOT = Path("input_label")

NEW_PROMPT_CONTEXT = """Your Role: You are an expert static analysis assistant with a deep understanding of Swift's semantic structure. Your mission is to meticulously analyze the provided symbol information to identify which symbols must have their names preserved during code obfuscation and to clearly justify your reasoning.

Input Data:
The input is a JSON object containing symbol information generated by analyzing Swift source code. Each symbol includes a `symbol_id`, a `symbol_name`, and an `input` field containing the data for analysis.

Procedure:
1.  **Symbol-by-Symbol Analysis**: For every symbol provided, thoroughly examine the data within its `input` field.
2.  **Identify Exclusions**: Identify symbols that must be excluded from obfuscation based on clear evidence matching one or more of the **'Core Analysis Patterns'** below.
3.  **Generate Output**: For the identified exclusion candidates only, generate a result conforming to the **'Output Format'** rules. Symbols that can be safely obfuscated should not be included in the final output.

Core Analysis Patterns (Decision Criteria):
-   **Runtime String References** (`objc_selector`, `stringly_typed_api`): When a symbol's name is referenced as a string at runtime, such as with `#selector` or `Notification.Name`.
-   **KVC/KVO and Data Binding** (`kvc_kvo`, `coredata_nsmanaged`): When a name is depended upon by mechanisms like `@NSManaged`, Key-Value Coding/Observing, or `KeyPath`.
-   **C Function Interface (FFI) Exposure** (`ffi_entry`): When a symbol is exposed to external C code via attributes like `@_cdecl`.
-   **Reflection** (`runtime_reflection`): When property names are used dynamically at runtime through APIs like `Mirror`.
-   **Codable Synthesis** (`codable_synthesis`): When the compiler automatically uses property names as keys, for instance, in JSON encoding/decoding.
-   **Resource Binding** (`resource_binding`): When a name is linked to external resources like Storyboard IDs, XIBs, or Asset names.
-   **External Contracts and Extensions** (`external_contract`): When a symbol is part of a framework's Public API.
-   **Dynamic Dispatch & ObjC Exposure** (`dynamic_dispatch`, `objc_exposed`): When a symbol is a target for ObjC runtime features via `dynamic` or `@objc` attributes.
-   **Protocol Requirement Implementation** (`protocol_requirement`): When a symbol is an implementation of a protocol's required method, property, etc.

Output Format:
The result is a JSON object containing **only the symbols that must be excluded from obfuscation**. Each symbol must consist of the following fields:

-   `symbol_name`: The pure name **excluding function arguments**.
    -   (e.g., `performRequest((endpoint: String))` -> `performRequest`)
-   `tags`: An array of standard tags corresponding to the reason for exclusion.
-   `rationale`: A clear, 1-2 sentence explanation for the exclusion, based on the `input` data.

Example Final Output:
{
  "methods": [
    {
      "symbol_name": "updateConfiguration",
      "tags": [
        "kvo"
      ],
      "rationale": "This method is declared '@objc dynamic' and can be a target for KVO (Key-Value Observing), requiring its name to be preserved."
    }
  ],
  "properties": [
    {
      "symbol_name": "baseURL",
      "tags": [
        "kvo"
      ],
      "rationale": "This property is declared '@objc dynamic' and can be a target for KVO (Key-Value Observing), requiring its name to be preserved."
    }
  ],
  "structs": [],
  "enums": []
}
"""


def build_analyzer(analyzer_dir: Path, bin_name: str) -> Path:
    """SwiftASTAnalyzer를 릴리즈 모드로 빌드하고 실행 파일 경로를 반환합니다."""
    print("🚀 SwiftASTAnalyzer 빌드를 시작합니다...")
    build_process = subprocess.run(
        ["swift", "build", "-c", "release"],
        cwd=analyzer_dir,
        check=True,
        capture_output=True,
        text=True,
    )
    print("✅ 빌드 완료!")

    analyzer_bin = analyzer_dir / ".build" / "release" / bin_name
    if not analyzer_bin.exists():
        raise FileNotFoundError(f"빌드 후에도 실행 파일을 찾을 수 없습니다: {analyzer_bin}")
    return analyzer_bin


def find_swift_files(root: Path, target_dirs: List[str]) -> List[Path]:
    """지정된 디렉토리 내 모든 .swift 파일을 검색합니다."""
    print("🔎 Swift 파일을 검색합니다...")
    swift_files = []
    for dir_name in target_dirs:
        search_path = root / dir_name
        if search_path.is_dir():
            files_found = list(search_path.rglob("*.swift"))
            swift_files.extend(files_found)
            print(f"   - '{search_path}'에서 {len(files_found)}개의 파일을 찾았습니다.")
    print(f"✨ 총 {len(swift_files)}개의 Swift 파일을 찾았습니다.")
    return swift_files


def update_prompt_context(data: dict, new_context: str) -> dict:
    """JSON 데이터의 meta.prompt_context 값을 새로운 내용으로 교체합니다."""
    if 'meta' in data and isinstance(data['meta'], dict):
        data['meta']['prompt_context'] = new_context
    return data


def analyze_single_file(
        swift_file: Path, analyzer_bin: Path, data_root: Path, output_root: Path
):
    """단일 Swift 파일을 분석하고, 빈 배열을 제거한 후 결과를 JSON 파일로 저장합니다."""
    try:
        # 출력 경로 계산
        relative_path = swift_file.relative_to(data_root)
        output_dir = output_root / relative_path.parent
        output_dir.mkdir(parents=True, exist_ok=True)
        output_file = output_dir / f"input_{swift_file.stem}.json"

        # Swift 분석기 실행
        result = subprocess.run(
            [str(analyzer_bin), str(swift_file)],
            capture_output=True,
            text=True,
            check=True,
            encoding="utf-8",
        )

        # 1. Swift 분석기 출력을 JSON 객체로 파싱
        data = json.loads(result.stdout)

        # 1a. prompt_context 내용을 새로운 텍스트로 교체
        data = update_prompt_context(data, NEW_PROMPT_CONTEXT)

        # 2. 'decisions' 딕셔너리 내부를 정리
        if 'decisions' in data and isinstance(data['decisions'], dict):
            decisions_data = data['decisions']

            # 2a. 각 심벌의 'input' 딕셔너리에서 빈 리스트를 가진 속성을 제거
            for category_list in decisions_data.values():
                if isinstance(category_list, list):
                    for symbol_obj in category_list:
                        if 'input' in symbol_obj and isinstance(symbol_obj['input'], dict):
                            input_data = symbol_obj['input']
                            input_keys_to_remove = [
                                key for key, value in input_data.items()
                                if isinstance(value, list) and not value
                            ]
                            for key in input_keys_to_remove:
                                del input_data[key]

            # 2b. 'decisions' 딕셔너리 자체에서 빈 리스트인 카테고리를 제거
            keys_to_remove = [
                key for key, value in decisions_data.items()
                if isinstance(value, list) and not value
            ]
            for key in keys_to_remove:
                del decisions_data[key]

        # 3. 정리된 JSON 객체를 다시 예쁘게 포맷된 문자열로 변환
        cleaned_json_string = json.dumps(data, indent=2, ensure_ascii=False)

        # 4. 최종 결과를 파일에 저장
        output_file.write_text(cleaned_json_string, encoding="utf-8")

        return None

    except json.JSONDecodeError:
        return f"❌ {swift_file} 분석 실패: Swift 분석기가 유효한 JSON을 생성하지 않았습니다."
    except subprocess.CalledProcessError as e:
        return f"❌ {swift_file} 분석 실패:\n{e.stderr}"
    except Exception as e:
        return f"❌ {swift_file} 처리 중 예외 발생:\n{e}"


def main():
    try:
        analyzer_bin = build_analyzer(ANALYZER_DIR, ANALYZER_BIN_NAME)
    except (subprocess.CalledProcessError, FileNotFoundError) as e:
        print(f"🔥 빌드 실패: {e}")
        return

    swift_files = find_swift_files(TARGET_DATA_ROOT, TARGET_DIRS_NAMES)
    if not swift_files:
        print("⚠️ 분석할 Swift 파일이 없습니다. 스크립트를 종료합니다.")
        return

    OUTPUT_ROOT.mkdir(parents=True, exist_ok=True)

    print(f"\n⚙️ 총 {len(swift_files)}개 파일에 대한 병렬 분석을 시작합니다...")

    worker_func = partial(
        analyze_single_file,
        analyzer_bin=analyzer_bin,
        data_root=TARGET_DATA_ROOT,
        output_root=OUTPUT_ROOT,
    )

    errors = []
    with ThreadPoolExecutor(max_workers=os.cpu_count()) as executor:
        results = list(tqdm(
            executor.map(worker_func, swift_files),
            total=len(swift_files),
            desc="파일 분석 중"
        ))

    for res in results:
        if res is not None:
            errors.append(res)

    print("\n--- 분석 완료 ---")
    if not errors:
        print(f"🎉 모든 파일({len(swift_files)}개)이 성공적으로 처리되었습니다!")
    else:
        print(f"🔥 {len(errors)}개의 파일에서 오류가 발생했습니다:")
        for error_log in errors:
            print(error_log)


if __name__ == "__main__":
    main()
